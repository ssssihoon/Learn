# Final

# 6.함수 중복과 Static멤버

## 함수 중복

- 다형성
- C언어에서는 불가능

### 범위

- 보통 함수들 사이
- 클래스의 멤버 함수들 사이
- 상속 관계에 있는 기본 클래스와 파생 클래스의 멤버 함수들 사이

### 함수 중복 성공 조건

- 중복된 함수들의 이름 동일
- 중복된 함수들의 매개 변수 타입이 다르거나 개수가 달라야 함
- 리턴 타입은 함수 중복과 무관

## 생성자 함수 중복

### 생성자 함수 중복 목적

- 객체 생성시, 매개 변수를 통해 다양한 형태의 초깃값 전달

### 소멸자 함수 중복 불가

- 소멸자는 매개 변수를 가지지 않음
- 한 클래스 내에서 소멸자는 오직 하나만 존재

## 디폴트 매개변수

- 디폴트 매개변수는 오른쪽 끝 쪽에 몰려 선언되어야 함.
- 디폴트 매개변수는 보통 매개변수 앞에 선언 불가
- 장점 : 함수 중복 간소화
- 중복 함수들과 디폴트 매개변수를 가진 함수를 함께 사용 불가

## 함수 중복의 모호성

- 형 변환으로 인한 모호성
- 참조 매개변수로 인한 모호성
- 디폴트 매개변수로 인한 모호성

### 형변환 모호성

3.0 → double 타입

3.0f → float 타입

### 참조 매개변수 모호성

```cpp
int add(int a, int b){}

int add(int a, int &b){}

add(s, t)
```

call by value인지 call by reference인지 모호함

### 디폴트 매개변수 모호성

```cpp
void msg(int id){
}
void msg(int id, string s = "hello")

msg(6);
```

디폴트 매개 변수를 이용하고 있는지 모호함

→ string s=”hello” 여기에도 포함된다고 함

## Static멤버

### static

- 생명주기 : 프로그램이 시작될 때 생성, 프로그램 종료 시 소멸
- 사용범위 : 선언된 범위, 접근 지정에 따름

### 클래스의 멤버

- static 멤버
    - 프로그램이 시작 할 때 생성
    - 클래스 당 하나만 생성, 클래스 멤버라고 불림
    - 클래스의 모든 인스턴스들이 공유하는 멤버
    - 객체 이름이나 객체 포인터로 접근 가능
- non-static 멤버
    - 객체가 생성될 때 함께 생성
    - 객체마다 객체 내에 생성
    - 인스턴스 멤버라고 부름

### static 활용

- 전역 변수나 전역 함수를 클래스에 캡슐화
- 객체 사이에 공유 변수를 만들고자 할 때

**Static 멤버함수는 Static 멤버만 접근 가능**

- static 멤버 함수가 접근할 수 있는 것
    - static 멤버함수
    - static 멤버변수
    - 함수 내의 지역 변수

**nonstatic 멤버 함수는 static에 접근 가능**

**static 멤버함수는 this 사용 불가**

# 7. 프렌드, 연산자 중복

## 프렌드 함수

- 클래스의 멤버 함수가 아닌 외부 함수
    - 전역 함수
    - 다른 클래스의 멤버 함수
- friend 키워드로 클래스 내에 선언된 함수
    - 클래스의 모든 멤버를 접근할 수 있는 권한 부여
    - 프렌드 함수라고 부름
- 프렌드 선언의 필요성
    - 클래스의 멤버로 선언하기에는 무리가 있고, 클래스의 모든 멤버를 자유롭게 접근할 수 있는 일부 외부 함수 작성 시 필요
- 프렌드 함수가 되는 3가지
    - 전역함수
    - 다른 클래스의 멤버 함수
    - 다른 클래스 전체

## 연산자 중복

### 중복 불가능한 연산자

- .
- .*
- ::
- ? :

### 연산자 함수 구현 방법 2가지

1. 클래스의 멤버 함수로 구현
2. 외부 함수로 구현하고 클래스에 프렌드 함수로 선언

### 연산자 함수 형식

- 리턴타입 operator연산자(매개변수리스트);

### 중요한 키포인트

중복연산자 사용 시 

int main부에서 값을 받아서 사용하지 않고 바로 변경이 필요하다면 operator 구현부에서 *this로 반환

### 후위연산자

- operator++ (int x){ power tmp = *this; ~

를 이용해서 증가 이전 객체 상태를 저장한다.

```cpp
Power Power::operator++(int x) {
    Power tmp = *this;
    kick ++;
    punch ++;
    return tmp;
}
```

# 8. 상속

- 다중 상속을 통해 클래스의 재활용성을 높임

## 상속의 목적 , 장점

1. 간결한 클래스 작성
2. 클래스 간의 계층적 분류 및 관리의 용의 함
3. 클래스 재사용과 확장을 통한 소프트웨어 생산성 향상

한마디로 재사용성으로 관리에 용이

### 상속관계의 생성자와 소멸자 실행

- 파생 클래스의 객체를 생성하면 어떻게 되는가?
    - 파생, 기본 둘 다 실행
- 파생 클래스의 생성자와 기본 클래스의 생성자 중 어떤 생성자가 먼저 실행되는가?
    - 기본 → 파생 → 파생 소멸 → 기본 소멸

# 9.가상함수와 추상클래스

## 가상함수

- virtual 키워드로 선언된 멤버함수
- 컴파일러에게 함수에 대한 호출 바인딩을 실행시간까지 미루도록 지시

## 함수 오버라이딩

- 파생 클래스에서 기본 클래스의 가상함수와 동일한 이름의 함수 선언
    - 가본 클래스의 가상 함수의 존재감 상실
    - 함수 재정의

Virtual 키워드를 사용함으로써 기본클래스의 동일 함수를 존재감 상실

## 동적 바인딩

- 파생클래스에 대해 기본클래스에 대한 포인터로 가상함수를 호출하는 경우

```cpp
class Shpae{
public:
	void paint();
	virtual void paint();
}

class Circle : public Shape{
public:
	virtual void paint();
}

int main(){
	Shape *p = new Circle(); // 업 캐스팅
	p->paint();
	delete p;
	}
```

기본클래스의 함수로 파생클래스의 paint()실행

## 오버라이딩 특징

### 오버라이딩 성공 조건

- 가상 함수 이름
- 매개 변수 타입과 개수
- 리턴 타입이 모두 일치

### 특징

- 오버라이딩 시 virtual 지시어 생략 가능
- 가상함수의 접근 지정 자유로움

### 상속이 반복되는 경우 가상 함수 호출

```cpp
Circle Base{
public:
	virtual void f();
	}
Circle der{
public:
	void f();
	}
Circle derder{
public:
	void f();
	}
	
```

bp→f(), dp→f(), ddp→f() 실행 결과로 derder의 f() 값이 나옴

### 파생클래스에서 기본클래스의 가상함수 호출

- 기본클래스::가상함수()

## 가상 소멸자

- 소멸자를 virtual 키워드로 선언
- 소멸자 호출 시 동적 바인딩 발생

```cpp
virtual ~Base();

virtual ~Derived();

int main(){
Base *p = new Derived();
delete p;
}
```

1. ~Base() 소멸자 호출
2. ~Derived() 실행
3. ~Base() 실행

## 추상 클래스의 목적

- 인스턴스 생성할 목적이 아님
- 상속에서 기본 클래스의 역할을 하기 위함
- 순수 가상함수를 통해 파생 클래스에서 구현할 함수의 원형형태를 보여주는 인터페이스 역할

## 추상 클래스의 상속과 구현

- 추상 클래스의 상속
    - 추상 클래스를 단순 상속하면 자동 추상 클래스
- 추상 클래스의 구현
    - 추상 클래스를 상속 받아 순수 가상 함수를 오버라이딩
        - 파생 클래스는 추상 클래스가 아님

# 10. 템플릿

## 일반화와 템플릿

### 제네릭 또는 일반화

- 함수나 클래스를 일반화 시키고, 매개 변수 타입을 지정하여 틀에서 찍어내듯이 함수나 클래스 코드를 생산하는 기법

### 템플릿

- 함수나 클래스를 일반화
- template 키워드로 함수나 클래스 선언

```cpp
template <class T1, class T2, ```>
```

## 구체화

- 템플릿의 제네릭 타입에 구체적인 타입 지정
- 일반적으로 알던 방법

제네릭 함수를 통해 구체화가 된다는 식

### 구체화 주의점

- 제네릭 타입에 구체적인 타입 지정 시 주의
- 매개변수에 같은 타입이 와야 한다.

## 템플릿 장점과 제네릭 프로그래밍

### 템플릿 장점

- 함수 코드의 재사용

### 템플릿 단점

- 포팅에 취약
- 컴파일 오류 메시지 빈약, 디버깅에 많은 어려움

### 템플릿 함수보다 중복함수가 우선이다.

## iterator

- 배열 포인터 함수라고 생각

## map 컨테이너

- (키, 값)의 쌍을 원소로 저장
- #include <map> 필요
- Map(string, string) dic;

## sort() 함수

- iterator와 함께 사용

## 람다식

[ ] ( ) → 리턴타입 { 함수 코드 작성 }

- 리턴타입 생략 가능